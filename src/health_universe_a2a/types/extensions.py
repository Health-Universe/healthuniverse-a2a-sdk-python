"""A2A Extension type definitions and constants for Health Universe platform."""

import logging
import uuid
from enum import Enum
from typing import Any

import httpx
from a2a.types import Artifact, Message, Part, Role, TaskState, TextPart
from pydantic import BaseModel, SecretStr

logger = logging.getLogger(__name__)

# Extension URIs for Health Universe platform

# File Access Extension (NestJS/S3)
FILE_ACCESS_EXTENSION_URI: str = "https://healthuniverse.com/ext/file_access/v2"

# Background Job Extension
BACKGROUND_JOB_EXTENSION_URI: str = "https://healthuniverse.com/ext/background_job/v1"

# Log Level Extension (for update importance)
HU_LOG_LEVEL_EXTENSION_URI: str = "https://healthuniverse.com/ext/log_level/v1"


class UpdateImportance(str, Enum):
    """
    Importance levels for status updates.

    These levels indicate the significance of a status update and control
    how updates are propagated to the Health Universe Navigator UI:

    - ERROR: Something went wrong (pushed to Navigator)
    - NOTICE: Standard progress update (default, pushed to Navigator)
    - INFO: Verbose logging (stored but not pushed to Navigator)
    - DEBUG: Detailed diagnostic information (stored but not pushed)

    NOTICE and ERROR level updates are pushed to the Navigator UI in real-time.
    All updates are stored in the A2A system for debugging and audit purposes.

    Example:
        # Default importance (NOTICE) - shown in Navigator
        await context.update_progress("Processing data...", progress=0.5)

        # Verbose logging - not shown in Navigator UI
        await context.update_progress(
            "Debug: processed 1000 rows",
            importance=UpdateImportance.INFO
        )
    """

    ERROR = "error"
    NOTICE = "notice"
    INFO = "info"
    DEBUG = "debug"


class NavigatorTaskStatus(str, Enum):
    """
    Task status values for the Health Universe Navigator UI.

    These map from A2A TaskState to Navigator-compatible status strings.
    The Navigator frontend expects these specific values.

    Note: Navigator currently maps canceled and rejected to "failed".
    """

    WORKING = "working"
    COMPLETED = "completed"
    FAILED = "failed"


class FileAccessExtensionContext(BaseModel):
    """
    Context metadata for file access extension.

    Specifies which files are available to the agent based on user and thread.

    Attributes:
        user_id: The ID of the user making the request
        thread_id: The ID of the thread/conversation context
    """

    user_id: str
    thread_id: str


class FileAccessExtensionParams(BaseModel):
    """
    Parameters for file access extension v2 (NestJS/S3).

    Passed in message metadata when the file access extension is enabled.
    The SDK automatically extracts these parameters and provides document
    access via context.document_client.

    Attributes:
        access_token: NestJS JWT for API authentication (marked as SecretStr
            to prevent accidental logging)
        context: Context metadata including user_id and thread_id

    Example:
        # Document operations are available via context.document_client
        async def process_message(self, message: str, context: AgentContext) -> str:
            docs = await context.document_client.list_documents()
            content = await context.document_client.download_text(docs[0].id)
            return f"Found {len(docs)} documents"
    """

    access_token: SecretStr  # NestJS JWT for API authentication
    context: FileAccessExtensionContext


class BackgroundJobExtensionParams(BaseModel):
    """
    Parameters for Background Job extension.

    Passed in message metadata under the BACKGROUND_JOB_EXTENSION_URI key.
    These parameters are used to identify the job and authenticate
    POST updates to the Health Universe backend.

    Note: The callback URLs (job_status_update_url, job_results_url) are passed
    at the TOP LEVEL of metadata, not inside this extension params object.

    Attributes:
        api_key: API key for POSTing updates to backend webhook
        job_id: Unique job ID for tracking this background task
    """

    api_key: str
    job_id: str


class BackgroundJobExtensionResponse(BaseModel):
    """
    Response metadata for background job acknowledgment.

    Included in the acknowledgment message when a background job is submitted.

    Attributes:
        job_id: The job ID that was submitted
    """

    job_id: str


class BackgroundTaskResults(BaseModel):
    """
    Results payload sent to webhook on background task completion.

    This model is sent to the job results webhook URL when a background
    task completes (successfully or with failure).

    Attributes:
        job_id: The job ID that completed
        state: Final task state (completed, failed, etc.)
        artifacts: List of artifacts generated by the task
    """

    job_id: str
    state: TaskState
    artifacts: list[Artifact]


def ack_background_job_enqueued(
    job_id: str,
    content: str | None = None,
    task_id: str | None = None,
    context_id: str | None = None,
) -> Message:
    """
    Create a standard acknowledgment message for background job submission.

    This helper creates a properly formatted A2A Message that acknowledges
    a background job has been submitted and will process asynchronously.
    Use this with updater.update_status() with final=True to close the
    SSE connection after acknowledgment.

    Args:
        job_id: The unique identifier for the background job
        content: Optional custom message content. If not provided, uses
            a default message explaining results will appear in artifacts pane.
        task_id: Optional task ID to include in message metadata
        context_id: Optional context ID to include in message metadata

    Returns:
        A properly formatted A2A Message with background job extension metadata

    Example:
        # In AsyncAgent.handle_request after validation:
        ack_message = ack_background_job_enqueued(
            job_id=bg_params.job_id,
            content="Starting analysis of your documents...",
            task_id=task.id,
            context_id=context_id,
        )
        await updater.update_status(
            TaskState.submitted,
            ack_message,
            final=True  # Close SSE connection
        )
    """
    base_message = (
        "This task is running in the background. "
        "You'll see the results in your artifacts pane once it finishes."
    )

    return Message(
        role=Role.agent,
        parts=[Part(root=TextPart(text=content or base_message))],
        message_id=str(uuid.uuid4()),
        task_id=task_id,
        context_id=context_id,
        extensions=[BACKGROUND_JOB_EXTENSION_URI],
        metadata={
            BACKGROUND_JOB_EXTENSION_URI: BackgroundJobExtensionResponse(job_id=job_id).model_dump()
        },
    )


async def notify_on_task_completion(
    api_key: str,
    result: BackgroundTaskResults,
    url: str | None = None,
) -> None:
    """
    Send task completion notification to the Health Universe backend webhook.

    This function is called when a background task completes (successfully or
    with failure) to notify the platform and deliver artifacts.

    Args:
        api_key: API key for authentication (from BackgroundJobExtensionParams)
        result: The task results including job_id, state, and artifacts
        url: Webhook URL passed from the platform (job_results_url).
            If not provided, the notification is skipped.

    Note:
        If api_key is "local-mode-key", the webhook notification is skipped
        (used for local development/testing).

    Example:
        await notify_on_task_completion(
            api_key=bg_params.api_key,
            result=BackgroundTaskResults(
                job_id=job_id,
                state=TaskState.completed,
                artifacts=artifacts,
            ),
            url=bg_params.job_results_url,
        )
    """
    # Skip webhook notification in local mode
    if api_key == "local-mode-key":
        logger.info("Local mode: Skipping webhook notification (artifacts saved to disk)")
        return

    if url is None:
        logger.debug("No job_results_url provided, skipping webhook notification")
        return

    headers: dict[str, str] = {"X-Api-Key": api_key}

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                url,
                json=result.model_dump(mode="json"),
                headers=headers,
            )

        if response.status_code == 200:
            logger.info(f"Task completion notification sent successfully for job {result.job_id}")
        else:
            logger.error(
                f"Task completion notification failed for job {result.job_id}: "
                f"{response.status_code} {response.text}"
            )
    except Exception as e:
        logger.error(f"Failed to send task completion notification for job {result.job_id}: {e}")


# Type alias for convenience
ExtensionMetadata = dict[str, Any]
